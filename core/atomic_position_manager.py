"""
Atomic Position Manager - –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç—å —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π —Å–æ stop-loss

CRITICAL: –≠—Ç–æ—Ç –º–æ–¥—É–ª—å –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π Entry+SL
–í—Å–µ –ø–æ–∑–∏—Ü–∏–∏ –î–û–õ–ñ–ù–´ –∏–º–µ—Ç—å stop-loss –∏–ª–∏ –±—ã—Ç—å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –∑–∞–∫—Ä—ã—Ç—ã

‚ö†Ô∏è DO NOT MODIFY –±–µ–∑ –ø–æ–ª–Ω–æ–≥–æ –ø–æ–Ω–∏–º–∞–Ω–∏—è –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏–π!
"""
import asyncio
import logging
from typing import Optional, Dict, Any
from enum import Enum
from contextlib import asynccontextmanager
from datetime import datetime, timezone
from decimal import Decimal
import uuid
from database.transactional_repository import TransactionalRepository
from core.event_logger import EventLogger, EventType, log_event
from core.exchange_response_adapter import ExchangeResponseAdapter

logger = logging.getLogger(__name__)


class PositionState(Enum):
    """
    –°–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏

    Flow: PENDING_ENTRY -> ENTRY_PLACED -> PENDING_SL -> ACTIVE
    –ü—Ä–∏ –ª—é–±–æ–π –æ—à–∏–±–∫–µ: -> FAILED –∏–ª–∏ ROLLED_BACK
    """
    PENDING_ENTRY = "pending_entry"  # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Ä–∞–∑–º–µ—â–µ–Ω–∏—é entry
    ENTRY_PLACED = "entry_placed"    # Entry —Ä–∞–∑–º–µ—â–µ–Ω, –æ–∂–∏–¥–∞–Ω–∏–µ SL
    PENDING_SL = "pending_sl"        # –†–∞–∑–º–µ—â–µ–Ω–∏–µ SL
    ACTIVE = "active"                # –ü–æ–∑–∏—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–∞ —Å –∑–∞—â–∏—Ç–æ–π
    FAILED = "failed"                # –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å
    ROLLED_BACK = "rolled_back"      # –û—Ç–∫–∞—á–µ–Ω–∞ –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ SL


class AtomicPositionError(Exception):
    """–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –Ω–∞—Ä—É—à–µ–Ω–∏–∏ –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏"""
    pass


class SymbolUnavailableError(Exception):
    """–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –∫–æ–≥–¥–∞ —Å–∏–º–≤–æ–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏ (–¥–µ–ª–∏—Å—Ç–∏–Ω–≥, —Ç–æ–ª—å–∫–æ –∑–∞–∫—Ä—ã—Ç–∏–µ –∏ —Ç.–¥.)"""
    pass


class AtomicPositionManager:
    """
    –ú–µ–Ω–µ–¥–∂–µ—Ä –∞—Ç–æ–º–∞—Ä–Ω–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π

    –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç:
    1. –ü–æ–∑–∏—Ü–∏—è –í–°–ï–ì–î–ê —Å–æ–∑–¥–∞–µ—Ç—Å—è —Å–æ stop-loss
    2. –ü—Ä–∏ –æ—à–∏–±–∫–µ SL –ø–æ–∑–∏—Ü–∏—è –æ—Ç–∫–∞—Ç—ã–≤–∞–µ—Ç—Å—è
    3. Recovery –¥–ª—è –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    """

    def __init__(self, repository, exchange_manager, stop_loss_manager):
        self.repository = repository
        self.exchange_manager = exchange_manager
        self.stop_loss_manager = stop_loss_manager
        self.active_operations = {}  # Track ongoing operations

    @asynccontextmanager
    async def atomic_operation(self, operation_id: str):
        """
        –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π

        –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:
        - –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
        - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π rollback –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
        - –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —ç—Ç–∞–ø–æ–≤
        """
        self.active_operations[operation_id] = {
            'started_at': datetime.utcnow(),  # FIX: Use offset-naive datetime for consistency
            'status': 'in_progress'
        }

        try:
            logger.info(f"üîÑ Starting atomic operation: {operation_id}")
            yield operation_id

            self.active_operations[operation_id]['status'] = 'completed'
            logger.info(f"‚úÖ Atomic operation completed: {operation_id}")

        except Exception as e:
            logger.error(f"‚ùå Atomic operation failed: {operation_id} - {e}")
            self.active_operations[operation_id]['status'] = 'failed'
            self.active_operations[operation_id]['error'] = str(e)

            # Rollback will be handled by caller
            raise

        finally:
            # Cleanup after delay
            asyncio.create_task(self._cleanup_operation_record(operation_id))

    async def _cleanup_operation_record(self, operation_id: str):
        """Cleanup operation record after 5 minutes"""
        await asyncio.sleep(300)
        if operation_id in self.active_operations:
            del self.active_operations[operation_id]

    async def open_position_atomic(
        self,
        signal_id: int,
        symbol: str,
        exchange: str,
        side: str,
        quantity: float,
        entry_price: float,
        stop_loss_price: float
    ) -> Optional[Dict[str, Any]]:
        """
        –ê—Ç–æ–º–∞—Ä–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Å –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º stop-loss

        Args:
            signal_id: ID —Å–∏–≥–Ω–∞–ª–∞
            symbol: –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–º–≤–æ–ª
            exchange: –ù–∞–∑–≤–∞–Ω–∏–µ –±–∏—Ä–∂–∏
            side: 'buy' –∏–ª–∏ 'sell'
            quantity: –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
            entry_price: –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞
            stop_loss_price: –£—Ä–æ–≤–µ–Ω—å stop-loss

        Returns:
            Dict —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø–æ–∑–∏—Ü–∏–∏ –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ

        Raises:
            AtomicPositionError: –ü—Ä–∏ –Ω–∞—Ä—É—à–µ–Ω–∏–∏ –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏
        """
        operation_id = f"pos_{symbol}_{datetime.now().timestamp()}"

        position_id = None
        entry_order = None
        sl_order = None
        state = PositionState.PENDING_ENTRY

        async with self.atomic_operation(operation_id):
            try:
                # Step 1: –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ–∑–∏—Ü–∏–∏ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ PENDING_ENTRY
                logger.info(f"üìù Creating position record for {symbol}")
                position_data = {
                    'signal_id': signal_id,
                    'symbol': symbol,
                    'exchange': exchange,
                    'side': 'long' if side.lower() == 'buy' else 'short',
                    'quantity': quantity,
                    'entry_price': entry_price,
                    'status': state.value,
                    'operation_id': operation_id
                }

                position_id = await self.repository.create_position(position_data)
                logger.info(f"‚úÖ Position record created: ID={position_id}")

                # Step 2: –†–∞–∑–º–µ—â–µ–Ω–∏–µ entry –æ—Ä–¥–µ—Ä–∞
                logger.info(f"üìä Placing entry order for {symbol}")
                state = PositionState.ENTRY_PLACED

                # FIX: exchange_manager is a dict, not an object with get_exchange method
                exchange_instance = self.exchange_manager.get(exchange)
                if not exchange_instance:
                    raise AtomicPositionError(f"Exchange {exchange} not available")

                raw_order = await exchange_instance.create_market_order(
                    symbol, side, quantity
                )

                # Normalize order response
                entry_order = ExchangeResponseAdapter.normalize_order(raw_order, exchange)

                if not ExchangeResponseAdapter.is_order_filled(entry_order):
                    raise AtomicPositionError(f"Entry order failed: {entry_order.status}")

                logger.info(f"‚úÖ Entry order placed: {entry_order.id}")

                # Update position with entry details
                # Extract execution price from normalized order
                exec_price = ExchangeResponseAdapter.extract_execution_price(entry_order)

                # FIX: Use only columns that exist in database schema
                await self.repository.update_position(position_id, **{
                    'entry_price': exec_price,  # Update existing entry_price field
                    'status': state.value,
                    'exchange_order_id': entry_order.id  # Track order ID
                })

                # Step 3: –†–∞–∑–º–µ—â–µ–Ω–∏–µ stop-loss —Å retry
                logger.info(f"üõ°Ô∏è Placing stop-loss for {symbol} at {stop_loss_price}")
                state = PositionState.PENDING_SL

                sl_placed = False
                max_retries = 3

                for attempt in range(max_retries):
                    try:
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º StopLossManager –¥–ª—è –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–∏ SL
                        sl_result = await self.stop_loss_manager.set_stop_loss(
                            symbol=symbol,
                            side='sell' if side.lower() == 'buy' else 'buy',
                            amount=quantity,
                            stop_price=stop_loss_price
                        )

                        if sl_result and sl_result.get('status') in ['created', 'already_exists']:
                            sl_placed = True
                            sl_order = sl_result
                            logger.info(f"‚úÖ Stop-loss placed successfully")
                            break

                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è SL attempt {attempt + 1}/{max_retries} failed: {e}")
                        if attempt < max_retries - 1:
                            await asyncio.sleep(2 ** attempt)  # Exponential backoff
                        else:
                            # Final attempt failed - MUST rollback
                            raise AtomicPositionError(
                                f"Failed to place stop-loss after {max_retries} attempts: {e}"
                            )

                if not sl_placed:
                    raise AtomicPositionError("Stop-loss placement failed")

                # Step 4: –ê–∫—Ç–∏–≤–∞—Ü–∏—è –ø–æ–∑–∏—Ü–∏–∏
                state = PositionState.ACTIVE
                # FIX: Use only columns that exist in database schema
                await self.repository.update_position(position_id, **{
                    'stop_loss_price': stop_loss_price,  # Setting this indicates SL is active
                    'status': state.value
                })

                logger.info(f"üéâ Position {symbol} is ACTIVE with protection")

                return {
                    'position_id': position_id,
                    'symbol': symbol,
                    'exchange': exchange,
                    'side': position_data['side'],
                    'quantity': quantity,
                    'entry_price': exec_price,  # Use extracted execution price
                    'stop_loss_price': stop_loss_price,
                    'state': state.value,
                    'entry_order': entry_order.raw_data,  # Return raw data for compatibility
                    'sl_order': sl_order
                }

            except Exception as e:
                # Check for Binance "Invalid symbol status" error
                error_str = str(e)
                if "code\":-4140" in error_str or "Invalid symbol status" in error_str:
                    logger.warning(f"‚ö†Ô∏è Symbol {symbol} is unavailable for trading (delisted or reduce-only): {e}")

                    # Clean up: Delete position from DB if it was created
                    if position_id:
                        try:
                            await self.repository.update_position(position_id, **{
                                'status': 'canceled',
                                'exit_reason': 'Symbol unavailable for trading'
                            })
                        except:
                            pass  # Ignore cleanup errors

                    # Raise specific exception for unavailable symbols
                    raise SymbolUnavailableError(f"Symbol {symbol} unavailable for trading on {exchange}")

                logger.error(f"‚ùå Atomic position creation failed: {e}")

                # CRITICAL: Rollback logic for other errors
                await self._rollback_position(
                    position_id=position_id,
                    entry_order=entry_order,
                    symbol=symbol,
                    exchange=exchange,
                    state=state,
                    error=str(e)
                )

                raise AtomicPositionError(f"Position creation rolled back: {e}")

    async def _rollback_position(
        self,
        position_id: Optional[int],
        entry_order: Optional[Any],
        symbol: str,
        exchange: str,
        state: PositionState,
        error: str
    ):
        """
        –û—Ç–∫–∞—Ç –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–∏ –æ—à–∏–±–∫–µ

        CRITICAL: –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —á—Ç–æ –Ω–µ –æ—Å—Ç–∞–µ—Ç—Å—è –ø–æ–∑–∏—Ü–∏–π –±–µ–∑ –∑–∞—â–∏—Ç—ã
        """
        logger.warning(f"üîÑ Rolling back position for {symbol}, state={state.value}")

        try:
            # –ï—Å–ª–∏ entry –±—ã–ª —Ä–∞–∑–º–µ—â–µ–Ω –Ω–æ –Ω–µ—Ç SL - –ö–†–ò–¢–ò–ß–ù–û!
            if entry_order and state in [PositionState.ENTRY_PLACED, PositionState.PENDING_SL]:
                logger.critical(f"‚ö†Ô∏è CRITICAL: Position without SL detected, closing immediately!")

                # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                # FIX: exchange_manager is a dict, not an object with get_exchange method
                exchange_instance = self.exchange_manager.get(exchange)
                if exchange_instance:
                    try:
                        # –ó–∞–∫—Ä—ã–≤–∞–µ–º market –æ—Ä–¥–µ—Ä–æ–º
                        # entry_order —Ç–µ–ø–µ—Ä—å NormalizedOrder
                        close_side = 'sell' if entry_order.side == 'buy' else 'buy'
                        close_order = await exchange_instance.create_market_order(
                            symbol, close_side, entry_order.filled
                        )
                        logger.info(f"‚úÖ Emergency close executed: {close_order.id}")
                    except Exception as close_error:
                        logger.critical(f"‚ùå FAILED to close unprotected position: {close_error}")
                        # TODO: Send alert to administrator

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ –ë–î
            if position_id:
                # FIX: update_position expects **kwargs, not dict as second argument
                await self.repository.update_position(position_id, **{
                    'status': PositionState.ROLLED_BACK.value,
                    'closed_at': datetime.utcnow(),  # FIX: Use offset-naive datetime for database compatibility
                    'exit_reason': f'rollback: {error}'
                })

        except Exception as rollback_error:
            logger.critical(f"‚ùå Rollback failed: {rollback_error}")

    async def recover_incomplete_positions(self):
        """
        Recovery –º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π

        –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –±–æ—Ç–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–∑–∏—Ü–∏–π,
        –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –ø—Ä–µ—Ä–≤–∞–Ω—ã –≤–æ –≤—Ä–µ–º—è —Å–æ–∑–¥–∞–Ω–∏—è
        """
        logger.info("üîç Checking for incomplete positions...")

        # –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏–∏ –≤ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏—è—Ö
        incomplete_states = [
            PositionState.PENDING_ENTRY.value,
            PositionState.ENTRY_PLACED.value,
            PositionState.PENDING_SL.value
        ]

        incomplete = await self.repository.get_positions_by_status(incomplete_states)

        if not incomplete:
            logger.info("‚úÖ No incomplete positions found")
            return

        logger.warning(f"‚ö†Ô∏è Found {len(incomplete)} incomplete positions")

        for pos in incomplete:
            try:
                symbol = pos['symbol']
                state = pos['status']

                logger.info(f"üîß Recovering position {symbol} in state {state}")

                if state == PositionState.PENDING_ENTRY.value:
                    # Entry –Ω–µ –±—ã–ª —Ä–∞–∑–º–µ—â–µ–Ω - –±–µ–∑–æ–ø–∞—Å–Ω–æ –ø–æ–º–µ—Ç–∏—Ç—å –∫–∞–∫ failed
                    # FIX: update_position expects **kwargs, not dict as second argument
                    await self.repository.update_position(pos['id'], **{
                        'status': PositionState.FAILED.value,
                        'exit_reason': 'incomplete: entry not placed'
                    })

                elif state == PositionState.ENTRY_PLACED.value:
                    # Entry —Ä–∞–∑–º–µ—â–µ–Ω –Ω–æ –Ω–µ—Ç SL - –ö–†–ò–¢–ò–ß–ù–û!
                    await self._recover_position_without_sl(pos)

                elif state == PositionState.PENDING_SL.value:
                    # –í –ø—Ä–æ—Ü–µ—Å—Å–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ SL - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∏ –∑–∞–≤–µ—Ä—à–∏—Ç—å
                    await self._complete_sl_placement(pos)

                logger.info(f"‚úÖ Recovered position {symbol}")

            except Exception as e:
                logger.error(f"‚ùå Failed to recover position {pos['id']}: {e}")

    async def _recover_position_without_sl(self, position: Dict):
        """–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –±–µ–∑ stop-loss"""
        symbol = position['symbol']

        logger.warning(f"üö® Recovering position without SL: {symbol}")

        # –ü—ã—Ç–∞–µ–º—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å SL
        try:
            sl_result = await self.stop_loss_manager.set_stop_loss(
                symbol=symbol,
                side='sell' if position['side'] == 'long' else 'buy',
                amount=position['quantity'],
                stop_price=position.get('planned_sl_price',
                          self._calculate_default_sl(position['entry_price'], position['side']))
            )

            if sl_result and sl_result.get('status') in ['created', 'already_exists']:
                # FIX: Use only columns that exist in database schema
                await self.repository.update_position(position['id'], **{
                    'stop_loss_price': sl_result.get('stopPrice'),  # Setting this indicates SL is active
                    'status': PositionState.ACTIVE.value
                })
                logger.info(f"‚úÖ SL restored for {symbol}")
            else:
                # –ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å SL - –∑–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
                await self._emergency_close_position(position)

        except Exception as e:
            logger.error(f"Failed to recover SL: {e}")
            await self._emergency_close_position(position)

    async def _complete_sl_placement(self, position: Dict):
        """–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è SL"""
        # Check if SL already exists
        has_sl = await self.stop_loss_manager.has_stop_loss(position['symbol'])

        if has_sl[0]:
            # SL —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
            # FIX: Use only columns that exist in database schema
            await self.repository.update_position(position['id'], **{
                'stop_loss_price': has_sl[1],  # Setting this indicates SL is active
                'status': PositionState.ACTIVE.value
            })
        else:
            # –ü—ã—Ç–∞–µ–º—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å SL
            await self._recover_position_without_sl(position)

    async def _emergency_close_position(self, position: Dict):
        """–≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –±–µ–∑ –∑–∞—â–∏—Ç—ã"""
        logger.critical(f"üö® EMERGENCY CLOSE for {position['symbol']}")

        try:
            # FIX: exchange_manager is a dict, not an object with get_exchange method
            exchange = self.exchange_manager.get(position['exchange'])
            if exchange:
                close_side = 'sell' if position['side'] == 'long' else 'buy'
                close_order = await exchange.create_market_order(
                    position['symbol'], close_side, position['quantity']
                )

                # FIX: Use only columns that exist in database schema
                await self.repository.update_position(position['id'], **{
                    'status': 'closed',
                    'closed_at': datetime.utcnow(),  # FIX: Use offset-naive datetime for database compatibility
                    'exit_reason': 'emergency: no stop loss',
                    'current_price': close_order.price if close_order else None  # Use current_price instead of exit_price
                })

                logger.info(f"‚úÖ Emergency close completed")
        except Exception as e:
            logger.critical(f"‚ùå Emergency close failed: {e}")
            # TODO: Send critical alert

    def _calculate_default_sl(self, entry_price: float, side: str, percent: float = 2.0) -> float:
        """–†–∞—Å—á–µ—Ç –¥–µ—Ñ–æ–ª—Ç–Ω–æ–≥–æ stop-loss"""
        if side == 'long':
            return entry_price * (1 - percent / 100)
        else:
            return entry_price * (1 + percent / 100)